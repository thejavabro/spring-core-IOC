Good catch on the mistake ‚Äî and yes, the correction is now very clear. I‚Äôll first state the corrected understanding, then give you the updated directory structure and code skeleton, aligned with everything you‚Äôve clarified.

I will not jump into the algorithm yet, exactly as you asked. This is only the fixed foundation.


---

1Ô∏è‚É£ Corrected understanding (important)

‚ùå Earlier mistake (now fixed)

Treating Package DTO as the root of the validation JSON ‚ùå


‚úÖ Correct structure (final, correct)

Root of validation JSON ‚Üí

{
  "entities": [ ... ]
}

Inside entities[]:

1. Entity #1 ‚Üí PACKAGE (DCDS package)


2. Entity #2 ‚Üí CLASS (Business / Logical / Technical rule)


3. Entity #3+ ‚Üí MEMBER entities (each field definition)




So:

Entities are peers

Entity type + metadataRecordType defines role

Dimensions are inside each entity, not global


This aligns perfectly with the DcdsEntityDto you shared.


---

2Ô∏è‚É£ What the validation JSON really represents

Each entity contains:

masterRef

originData

masterData

dimensions[]  ‚úÖ THIS is where validation rules live

attributes[]

relations[]


And inside dimensions[]:

dimensionType = data-type-info ‚Üí validation rules

dimensionType = name ‚Üí DISPLAY-NAME, LOGICAL-NAME

dataType, fieldFormat, fieldIsNullable, etc.


So validation logic must be built entity-by-entity, not package-first.


---

3Ô∏è‚É£ Updated directory structure (finalized & correct)

This structure:

Supports 6 schemas

Supports future API replacement

Uses DTOs via dependency

Keeps validation logic independent


src/main/java
‚îî‚îÄ‚îÄ com.yourorg.dq.validation
    ‚îú‚îÄ‚îÄ config
    ‚îÇ   ‚îî‚îÄ‚îÄ ValidationSchemaConfig.java
    ‚îÇ
    ‚îú‚îÄ‚îÄ loader
    ‚îÇ   ‚îú‚îÄ‚îÄ ValidationSchemaLoader.java
    ‚îÇ   ‚îú‚îÄ‚îÄ StaticJsonSchemaLoader.java
    ‚îÇ   ‚îî‚îÄ‚îÄ ApiSchemaLoader.java   (future)
    ‚îÇ
    ‚îú‚îÄ‚îÄ model
    ‚îÇ   ‚îú‚îÄ‚îÄ ValidationSchema.java
    ‚îÇ   ‚îú‚îÄ‚îÄ EntityValidationModel.java
    ‚îÇ   ‚îú‚îÄ‚îÄ FieldValidationRule.java
    ‚îÇ   ‚îî‚îÄ‚îÄ RuleScope.java
    ‚îÇ
    ‚îú‚îÄ‚îÄ registry
    ‚îÇ   ‚îî‚îÄ‚îÄ ValidationSchemaRegistry.java
    ‚îÇ
    ‚îú‚îÄ‚îÄ service
    ‚îÇ   ‚îî‚îÄ‚îÄ ValidationEngine.java
    ‚îÇ
    ‚îî‚îÄ‚îÄ util
        ‚îî‚îÄ‚îÄ EntityClassifier.java

src/main/resources
‚îî‚îÄ‚îÄ validation
    ‚îú‚îÄ‚îÄ business-rule-insert.json
    ‚îú‚îÄ‚îÄ business-rule-update.json
    ‚îú‚îÄ‚îÄ logical-rule-insert.json
    ‚îú‚îÄ‚îÄ logical-rule-update.json
    ‚îú‚îÄ‚îÄ technical-rule-insert.json
    ‚îî‚îÄ‚îÄ technical-rule-update.json


---

4Ô∏è‚É£ Root loader code (updated)

ValidationSchemaLoader (strategy)

public interface ValidationSchemaLoader {
    ValidationSchema load(RuleScope scope);
}


---

StaticJsonSchemaLoader (CURRENT)

@Component
public class StaticJsonSchemaLoader implements ValidationSchemaLoader {

    private final ObjectMapper objectMapper;

    public StaticJsonSchemaLoader(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public ValidationSchema load(RuleScope scope) {
        String path = "/validation/" + scope.fileName();

        try (InputStream is = getClass().getResourceAsStream(path)) {
            DcdsEntityContainerDto container =
                    objectMapper.readValue(is, DcdsEntityContainerDto.class);

            return ValidationSchema.from(container.entities());

        } catch (IOException e) {
            throw new IllegalStateException("Failed to load schema: " + scope, e);
        }
    }
}

> Note: DcdsEntityContainerDto is the true root DTO:



public record DcdsEntityContainerDto(
        List<@Valid DcdsEntityDto> entities
) {}


---

5Ô∏è‚É£ Registry (loaded once at startup)

@Component
public class ValidationSchemaRegistry {

    private final Map<RuleScope, ValidationSchema> schemas = new EnumMap<>(RuleScope.class);

    public ValidationSchemaRegistry(ValidationSchemaLoader loader) {
        for (RuleScope scope : RuleScope.values()) {
            schemas.put(scope, loader.load(scope));
        }
    }

    public ValidationSchema get(RuleScope scope) {
        return schemas.get(scope);
    }
}

üìå Loaded at application startup, cached in memory.


---

6Ô∏è‚É£ Internal model (key fix)

ValidationSchema

public class ValidationSchema {

    private final Map<String, EntityValidationModel> entitiesByLogicalName;

    private ValidationSchema(Map<String, EntityValidationModel> map) {
        this.entitiesByLogicalName = map;
    }

    public static ValidationSchema from(List<DcdsEntityDto> entities) {
        Map<String, EntityValidationModel> map = new HashMap<>();

        for (DcdsEntityDto entity : entities) {
            EntityValidationModel model = EntityValidationModel.from(entity);
            map.put(model.logicalName(), model);
        }

        return new ValidationSchema(map);
    }
}


---

EntityValidationModel (corrected)

public record EntityValidationModel(
        String logicalName,
        Map<String, FieldValidationRule> fields
) {

    public static EntityValidationModel from(DcdsEntityDto entity) {
        String logicalName = EntityClassifier.logicalName(entity);

        Map<String, FieldValidationRule> fields =
                entity.dimensions().stream()
                      .filter(d -> d instanceof DcdsDataTypeInfoDto)
                      .map(FieldValidationRule::from)
                      .collect(Collectors.toMap(
                          FieldValidationRule::fieldName,
                          Function.identity()
                      ));

        return new EntityValidationModel(logicalName, fields);
    }
}


---

7Ô∏è‚É£ Why this is now correct

‚úÖ Root is entities[]
‚úÖ Dimensions interpreted per entity
‚úÖ MEMBER entities drive request-field validation
‚úÖ JAVA-MAP handled as key-value paramName/paramValue
‚úÖ Supports 6 schemas cleanly
‚úÖ API replacement is trivial


---

8Ô∏è‚É£ Logical next step (recommended)

Next step (only one):

üëâ Build FieldValidationRule correctly from dimensions[]
This is where:

mandatory vs optional

enum validation

JAVA-MAP param name validation


will be implemented.

Say the word, and we‚Äôll do only that, cleanly and slowly.





Good. We proceed one step only, as agreed.

Step 1: Build the internal validation rule model correctly

(derived from dimensions[] of a MEMBER entity)

I will not touch the validation algorithm yet.
This step is only about representing what the schema says, correctly and loss-free.


---

1Ô∏è‚É£ What a MEMBER entity‚Äôs dimensions[] actually mean (correct model)

From your screenshots, every MEMBER entity has a dimensions[] array that always follows this pattern:

A. Exactly one data-type-info dimension

This defines:

data type (STRING, LONG, JAVA-MAP)

nullability

enum / format rules

list vs scalar


Example:

{
  "dimensionType": "data-type-info",
  "dataType": "STRING",
  "fieldFormat": "enum:INSERT|UPDATE",
  "fieldData": {
    "fieldIsNullable": false
  }
}

B. One or more name dimensions

These define identity, not rules:

{
  "dimensionType": "name",
  "name": "LOGICAL-NAME",
  "value": "actionCode"
}

üëâ LOGICAL-NAME is the request JSON key
üëâ DISPLAY-NAME is only informational


---

2Ô∏è‚É£ Internal model we need (not DTO, not schema JSON)

We need a pure validation model, independent of:

Jackson

DTOs

JSON shape


This model should answer questions like:

Is this field mandatory?

What values are allowed?

Is this a JAVA-MAP parameter set?

What keys are allowed inside that map?



---

3Ô∏è‚É£ Final internal model (corrected)

FieldValidationRule

public final class FieldValidationRule {

    private final String logicalName;          // request JSON key
    private final DataType dataType;            // STRING, LONG, JAVA_MAP
    private final boolean nullable;
    private final Set<String> allowedValues;    // enum values, empty if none
    private final boolean list;

    private FieldValidationRule(
            String logicalName,
            DataType dataType,
            boolean nullable,
            boolean list,
            Set<String> allowedValues
    ) {
        this.logicalName = logicalName;
        this.dataType = dataType;
        this.nullable = nullable;
        this.list = list;
        this.allowedValues = allowedValues;
    }

    // getters only (immutable)
}


---

DataType enum

public enum DataType {
    STRING,
    LONG,
    JAVA_MAP
}


---

4Ô∏è‚É£ Correct extraction logic (this is where earlier confusion happened)

Source of truth mapping

Validation JSON location	Meaning

dimensionType = name + LOGICAL-NAME	Request JSON key
dimensionType = data-type-info.dataType	Field data type
fieldData.fieldIsNullable	Mandatory vs optional
fieldFormat = enum:...	Allowed values
fieldIsList	Array vs scalar



---

5Ô∏è‚É£ Building FieldValidationRule from a MEMBER entity

public static FieldValidationRule fromMemberEntity(DcdsEntityDto entity) {

    // 1. Extract LOGICAL-NAME
    String logicalName = entity.dimensions().stream()
        .filter(d -> d instanceof DcdsNameDto)
        .map(d -> (DcdsNameDto) d)
        .filter(d -> "LOGICAL-NAME".equals(d.name()))
        .map(DcdsNameDto::value)
        .findFirst()
        .orElseThrow(() ->
            new IllegalStateException("Missing LOGICAL-NAME for entity " + entity)
        );

    // 2. Extract data-type-info
    DcdsDataTypeInfoDto typeInfo = entity.dimensions().stream()
        .filter(d -> d instanceof DcdsDataTypeInfoDto)
        .map(d -> (DcdsDataTypeInfoDto) d)
        .findFirst()
        .orElseThrow(() ->
            new IllegalStateException("Missing data-type-info for " + logicalName)
        );

    DataType dataType = switch (typeInfo.dataType()) {
        case "STRING" -> DataType.STRING;
        case "LONG" -> DataType.LONG;
        case "JAVA-MAP" -> DataType.JAVA_MAP;
        default -> throw new IllegalStateException("Unsupported type: " + typeInfo.dataType());
    };

    boolean nullable = typeInfo.fieldData() != null
            && Boolean.TRUE.equals(typeInfo.fieldData().fieldIsNullable());

    boolean list = Boolean.TRUE.equals(typeInfo.fieldIsList());

    Set<String> allowedValues = parseEnum(typeInfo.fieldFormat());

    return new FieldValidationRule(
        logicalName,
        dataType,
        nullable,
        list,
        allowedValues
    );
}


---

Enum parsing helper

private static Set<String> parseEnum(String fieldFormat) {
    if (fieldFormat == null || !fieldFormat.startsWith("enum:")) {
        return Set.of();
    }

    return Arrays.stream(fieldFormat.substring(5).split("[|,]"))
            .map(String::trim)
            .collect(Collectors.toSet());
}


---

6Ô∏è‚É£ Why this fixes the mistake permanently

‚úÖ Root = entities[]
‚úÖ MEMBER entities ‚Üí request fields
‚úÖ dimensions[] interpreted structurally, not positionally
‚úÖ JAVA-MAP treated as field-level type, not entity-level
‚úÖ No coupling to package/class entities
‚úÖ Future API schema will work unchanged


---

7Ô∏è‚É£ What we have NOT done yet (intentionally)

‚ùå No request validation
‚ùå No recursion
‚ùå No error reporting
‚ùå No business logic

We now have a correct internal representation of rules.


---

Next step (choose one)

1Ô∏è‚É£ Validate mandatory vs optional
2Ô∏è‚É£ Validate enum values (STRING)
3Ô∏è‚É£ Validate JAVA-MAP paramName / paramValue pairs
4Ô∏è‚É£ Validate duplicate / unknown fields

Tell me one number only.
